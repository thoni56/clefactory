## Functional Overview

This is very much an initial schetch and also some design ideas.

- the compile_commands.json defines the "project" and thus all translation units
- we need to get all recursively included files (unless pruned) and their modification times
- all files modified since last command will trigger a refresh of the index for dependent translation units
- 

### Compilation Database

ChatGPT:

Yes, there is a simple way to specify a compilation database when using libclang. Clang provides a utility function `clang_CompilationDatabase_fromDirectory()` that you can use to create a `CXCompilationDatabase` object from a directory that contains a `compile_commands.json` file. The `compile_commands.json` file is typically generated by build systems such as CMake, and it lists the command line arguments and working directory for each translation unit in the project.

Once you have created a `CXCompilationDatabase` object, you can use the `clang_CompilationDatabase_getCompileCommands()` function to retrieve the command line arguments for a specific file. You can then pass these command line arguments to `clang_parseTranslationUnit()` to create a translation unit for the file.

Here is an example of how you might use the `clang_CompilationDatabase_fromDirectory()` and `clang_CompilationDatabase_getCompileCommands()` functions in C99:

```
#include <clang-c/Index.h>

int main(int argc, const char **argv) {
  const char *file_to_parse = argv[1];
  const char *compilation_db_dir = argv[2];

  // Create a compilation database from a directory
  CXCompilationDatabase_Error error;
  CXCompilationDatabase compilation_db = clang_CompilationDatabase_fromDirectory(
      compilation_db_dir, &error);
  if (error != CXCompilationDatabase_NoError) {
    // Handle error
  }

  // Get the compile command for the file to parse
  CXCompileCommands compile_commands = clang_CompilationDatabase_getCompileCommands(
      compilation_db, file_to_parse);
  int num_commands = clang_CompileCommands_getSize(compile_commands);
  if (num_commands == 0) {
    // Handle error
  }

  // Get the first compile command
  CXCompileCommand compile_command = clang_CompileCommands_getCommand(
      compile_commands, 0);
  int num_args = clang_CompileCommand_getNumArgs(compile_command);
  char **args = (char **)malloc(sizeof(char *) * num_args);
  for (int i = 0; i < num_args; i++) {
    args[i] = clang_CompileCommand_getArg(compile_command, i);
  }

  // Parse the translation unit using the command line arguments
  CXIndex index = clang_createIndex(0, 0);
  CXTranslationUnit tu = clang_parseTranslationUnit(
      index, file_to_parse, args, num_args,
      NULL, 0, CXTranslationUnit_None);

  // Clean up
  clang_CompileCommands_dispose(compile_commands);
  clang_CompilationDatabase_dispose(compilation_db);
  clang_disposeIndex(index);
  free(args);

  return 0;
}
```

Note that in this example, the compilation_db_dir argument is assumed to be the directory containing the compile_commands.json file
